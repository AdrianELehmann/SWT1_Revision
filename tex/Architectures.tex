\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}

\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Vorteile}[section]
\newtheorem{whynot}{Nachteile}[section]
\title{SWT 1: Architekturstile by example}
\author{Adrian E. Lehmann}

\begin{document}
	\maketitle
	\tableofcontents
	\newpage
	

\section{Softwaretypen}
\subsection{Abstrakte Maschine}
Auch virtuelle Maschine oder \textit{engl. Virtual Machine (VM)}
\begin{defi}
	Eine virtuelle Maschine ist eine Menge an Befehlen und Objekten, die auf einer darunter liegenden Maschine aufbauen und diese ganz oder teilweise verdecken
\end{defi}

\begin{ex}
\begin{enumerate}
	\item JVM
	\item KVM / VirtualBox / etc
\end{enumerate}
\end{ex}

\begin{why}
		Man verwendet virtuelle Maschinen um ein System zu kapseln und somit eine kontrollierte Umgebung zu haben. Eine kontrollierte Umgebung hat Vorteile für das Host- sowie das Gastsystem: Das Hostsystem kann unbehelligt weiter arbeiten und es erfolgen keinerlei ungewollte Änderungen durch das Gastsystem auf diesem. Das Gastsystem hingegen kann in seiner 'idealen' Umgebung verwendet werden und kann somit optimal laufen. Weiterhin kann man so Software für mehrere System einfach ausliefern: In dem diese System eine kompatible VM installiert haben, kann die erstelle Software ausgeführt werden (bestes Beispiel: Java)
\end{why}

\subsection{Programmfamilie}
Auch Software-Produktlinie oder \textit{engl. Program Family}
\begin{defi}
	Eine Programmfamilie ist eine Menge von Software welche erhebliche Anteile von Anforderungen, Entwurfsbestandteilen oder Softwarekomponenten gemeinsam verwenden.
	Die Programme einer solchen Familie unterscheiden sich extern durch I/O, Funktionsumfang und der Zielhardware und intern durch evtl. verschiedene Algorithmen und/oder Datenstrukturen.
\end{defi}

\begin{ex}
	\begin{enumerate}
		\item LibreOffice
		\item Creative Cloud
	\end{enumerate}
\end{ex}

\begin{why}
	Auf Grund der Wiederverwendung von Komponenten wird die Entwicklung kürzer und kostengünstiger. Weiterhin werden die Programme hiermit besser wartbar, da man Funktionalitätsupdates an die ganze Produktfamilie 'auf einmal' ausliefern kann.
\end{why}
\newpage
\section{Benötigte Definitionen}
\subsection{Schicht}

\textit{engl. Layer}
\begin{defi}{Schicht}
	Eine Schicht besteht aus Softwarekomponenten, welche durch eine (wohldefinierte) Schnittstelle zur Verfügung gestellt werden.
\end{defi}

Eine Schicht kann wiederum in mehrere sog. Partitionen aufgeteilt werden, welche untereinander auch kommunizieren können. Schichten könne i.A. untereinander nicht kommunizieren (siehe Schichtenarchitektur).
\section{Architekturstile}
\subsection{Schichtenarchitektur}
\textit{engl. Layered Architecture}

\begin{defi}
	Eine Schichten Architektur glieder Software in einzelne Schichten
\end{defi}
Es gibt mehrere Typen einer Schichtenarchitektur: 
\begin{itemize}
	\item Eine transparente Schichtenarchitektur erlaubt es das jede Schicht auf die Schnittstelle jeder Schicht unter ihr zugreifen darf.
	\item Eine intransparente Schichtenarchitektur erlaubt einer Schicht nur den Zugriff auf die Schnittstelle der Schicht direkt unter ihr selbst.
\end{itemize}

\begin{why}
	\begin{enumerate}
		\item Zur Übersichtlichkeit der Modellierung / der Software
		\item Um Abstraktionsebenen zu definieren
		\item Die Wartbarkeit wird verbessert, da man Schichten einfach gegen andere Implementierungen tauschen kann
		\item Die Wiederverwertbarkeit zwischen Software wird verbessert
		
	\end{enumerate}
\end{why}
\begin{whynot}
	\begin{enumerate}
		\item Schichtenaufteilung manchmal schwierig
		\item Kommunikation u. U. umständlich (gerade bei falls intransparent)
	\end{enumerate}
\end{whynot}
Zur Implementierung siehe das Entwurfsmuster Fassade.

\end{document}

