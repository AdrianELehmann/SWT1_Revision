\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}

\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Vorteile}[section]
\newtheorem{whynot}{Nachteile}[section]
\title{SWT 1: Architekturstile by example}
\author{Adrian E. Lehmann}

\begin{document}
	\maketitle
	\tableofcontents
	\newpage
	

\section{Softwaretypen}
\subsection{Abstrakte Maschine}
Auch virtuelle Maschine oder \textit{engl. Virtual Machine (VM)}
\begin{defi}
	Eine virtuelle Maschine ist eine Menge an Befehlen und Objekten, die auf einer darunter liegenden Maschine aufbauen und diese ganz oder teilweise verdecken
\end{defi}

\begin{ex}
\begin{enumerate}
	\item JVM
	\item KVM / VirtualBox / etc
\end{enumerate}
\end{ex}

\begin{why}
		Man verwendet virtuelle Maschinen um ein System zu kapseln und somit eine kontrollierte Umgebung zu haben. Eine kontrollierte Umgebung hat Vorteile für das Host- sowie das Gastsystem: Das Hostsystem kann unbehelligt weiter arbeiten und es erfolgen keinerlei ungewollte Änderungen durch das Gastsystem auf diesem. Das Gastsystem hingegen kann in seiner 'idealen' Umgebung verwendet werden und kann somit optimal laufen. Weiterhin kann man so Software für mehrere System einfach ausliefern: In dem diese System eine kompatible VM installiert haben, kann die erstelle Software ausgeführt werden (bestes Beispiel: Java)
\end{why}

\subsection{Programmfamilie}
Auch Software-Produktlinie oder \textit{engl. Program Family}
\begin{defi}
	Eine Programmfamilie ist eine Menge von Software welche erhebliche Anteile von Anforderungen, Entwurfsbestandteilen oder Softwarekomponenten gemeinsam verwenden.
	Die Programme einer solchen Familie unterscheiden sich extern durch I/O, Funktionsumfang und der Zielhardware und intern durch evtl. verschiedene Algorithmen und/oder Datenstrukturen.
\end{defi}

\begin{ex}
	\begin{enumerate}
		\item LibreOffice
		\item Creative Cloud
	\end{enumerate}
\end{ex}

\begin{why}
	Auf Grund der Wiederverwendung von Komponenten wird die Entwicklung kürzer und kostengünstiger. Weiterhin werden die Programme hiermit besser wartbar, da man Funktionalitätsupdates an die ganze Produktfamilie 'auf einmal' ausliefern kann.
\end{why}
\newpage
\section{Benötigte Definitionen}
\subsection{Schicht}

\textit{engl. Layer}
\begin{defi}{Schicht}
	Eine Schicht besteht aus Softwarekomponenten, welche durch eine (wohldefinierte) Schnittstelle zur Verfügung gestellt werden.
\end{defi}

Eine Schicht kann wiederum in mehrere sog. Partitionen aufgeteilt werden, welche untereinander auch kommunizieren können. Schichten könne i.A. untereinander nicht kommunizieren (siehe Schichtenarchitektur).
\section{Architekturstile}
\subsection{Schichtenarchitektur}
\textit{engl. Layered Architecture}

\begin{defi}
	Eine Schichten Architektur glieder Software in einzelne Schichten
\end{defi}
Es gibt mehrere Typen einer Schichtenarchitektur: 
\begin{itemize}
	\item Eine transparente Schichtenarchitektur erlaubt es das jede Schicht auf die Schnittstelle jeder Schicht unter ihr zugreifen darf.
	\item Eine intransparente Schichtenarchitektur erlaubt einer Schicht nur den Zugriff auf die Schnittstelle der Schicht direkt unter ihr selbst.
\end{itemize}

\begin{why}
	\begin{enumerate}
		\item Zur Übersichtlichkeit der Modellierung / der Software
		\item Um Abstraktionsebenen zu definieren
		\item Die Wartbarkeit wird verbessert, da man Schichten einfach gegen andere Implementierungen tauschen kann
		\item Die Wiederverwertbarkeit zwischen Software wird verbessert
		
	\end{enumerate}
\end{why}
\begin{whynot}
	\begin{enumerate}
		\item Schichtenaufteilung manchmal schwierig
		\item Kommunikation u. U. umständlich (gerade bei falls intransparent)
	\end{enumerate}
\end{whynot}
Zur Implementierung siehe das Entwurfsmuster Fassade.


\subsection{Klient / Dienstgeber}
\textit{engl. bzw. allgemein verständlich: Client/Server}
\begin{defi}
	Eine Architektur in welcher ein Dienstgeber einem oder mehreren Klienten Dienste anbietet. Dabei rufen die einzelnen Klienten Funktionen auf dem Dienstgeber auf.
\end{defi}
\begin{itemize}
	\item Der Klient muss die Schnittstelle des Dienstgebers kennen
	\item Umgekehrt ist dies nicht der Fall
\end{itemize}
\begin{ex}
	Ein Dienstgeber bietet häufig ein Datenbankbackend, auf welches die Klienten (meist Applikationen) zugreifen. Beispiele hierfür sind quasi unendlich verfügbar. Das wohl weit verbreitetste sind "WebServer" also Dienstgeber die einem eine Webseite zur Verfügung stellen.
\end{ex}
\begin{why}
	\begin{itemize}
		\item Software kann "geheim" gehalten werden
		\item Schwachen Klienten, wie z.B. Smartphones, kann Arbeit abgenommen werden
	\end{itemize}
\end{why}
\begin{whynot}
	\begin{itemize}
		\item Evtl. viel Rechenleistung nötig und somit teuer
		\item Zentralisierung bietet Angriffsfläche
		\item Datenschutz u. U. fragwürdig
	\end{itemize}
\end{whynot}


\subsection{Partnernetze}
\textit{engl. bzw. allgemein verständlich: Peer to peer (P2P) network}
\begin{defi}
	Eine Verallgemeinerung des Klient Dienstgebersystems, bei dem alle Netzwerkpartner die gleichen Aufgaben und Rechte haben.
\end{defi}
\textbf{Wichtige Eigenschaften:}
\begin{itemize}
	\item Partnernetze sind \textbf{dezentralisiert}
	\item \textbf{Rollensymmetrie}: Alle Partner sind Klient und Dienstgeber zu gleich
	\item \textbf{Selbstorganisation}: Die korrekte Funktionalität und das Verhalten wird durch die Interaktion und durch die Kommunikation der Partner gesteuert
	\item \textbf{Verfügbarkeit}: Alle Daten sind redundant über mehrere Partner verteilt
	\item \textbf{Autonomie}Autonomie: Jeder Partner arbeitet für sich ohne Einfluss der anderen
	\item \textbf{Zuverlässigkeit}: Ein Partnernetz hat eine hohe Ausfallsicherheit auf Grund der hohen Redundanz
\end{itemize}
\begin{ex}
	\begin{itemize}
		\item Torrent
		\item Dezentrale Kommunikationsdienst (z.B Matrix)
		\item Skype (Teilweise)
		\item Blockchain (z.B. Bitcoin)
	\end{itemize}
\end{ex}
\begin{why}
	\begin{itemize}
		\item Sicherheit
		\item Datenschutz
		\item Lastverteilung
	\end{itemize}
\end{why}
\begin{whynot}
	\begin{itemize}
		\item Notwendige Weitergabe der Software
		\item Leichterer Eindrang für schwarze Schafe (wenn auch gut kontrollierbar)
	\end{itemize}
\end{whynot}



\subsection{Partnernetze}
\textit{engl. bzw. allgemein verständlich: Peer to peer (P2P) network}
\begin{defi}
	Eine Verallgemeinerung des Klient Dienstgebersystems, bei dem alle Netzwerkpartner die gleichen Aufgaben und Rechte haben.
\end{defi}
\textbf{Wichtige Eigenschaften:}
\begin{itemize}
	\item Partnernetze sind \textbf{dezentralisiert}
	\item \textbf{Rollensymmetrie}: Alle Partner sind Klient und Dienstgeber zu gleich
	\item \textbf{Selbstorganisation}: Die korrekte Funktionalität und das Verhalten wird durch die Interaktion und durch die Kommunikation der Partner gesteuert
	\item \textbf{Verfügbarkeit}: Alle Daten sind redundant über mehrere Partner verteilt
	\item \textbf{Autonomie}Autonomie: Jeder Partner arbeitet für sich ohne Einfluss der anderen
	\item \textbf{Zuverlässigkeit}: Ein Partnernetz hat eine hohe Ausfallsicherheit auf Grund der hohen Redundanz
\end{itemize}
\begin{ex}
	\begin{itemize}
		\item Torrent
		\item Dezentrale Kommunikationsdienst (z.B Matrix)
		\item Skype (Teilweise)
		\item Blockchain (z.B. Bitcoin)
	\end{itemize}
\end{ex}
\begin{why}
	\begin{itemize}
		\item Sicherheit
		\item Datenschutz
		\item Lastverteilung
	\end{itemize}
\end{why}
\begin{whynot}
	\begin{itemize}
		\item Notwendige Weitergabe der Software
		\item Leichterer Eindrang für schwarze Schafe (wenn auch gut kontrollierbar)
	\end{itemize}
\end{whynot}
\end{document}

