\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[light,condensed,math]{kurier}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}
\usepackage{graphicx}
\usepackage{floatrow}
\usepackage{float}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{soul} % Underline

\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Vorteile}[section]
\newtheorem{whynot}{Nachteile}[section]

\setul{1.5pt}{.4pt}
\title{SWT 1: Testen}
\author{Sebastian Markgraf \& Adrian E. Lehmann}

\begin{document}
	\maketitle
	\begin{large}
	\begin{center} „Testing shows the presence of bugs, not their absence.“\newline
		- Edsger W. Dijkstra
	\end{center}
	\end{large}
	\tableofcontents
	\newpage
        \section{Arten von Fehlern}
        \begin{defi}
          \textbf{Versagen} - Abweichung des Verhaltens der Software von der Spezifikation (ein Ereignis)
        \end {defi}
        \begin{defi}
          \textbf{Defekt} - ist ein Mangel in einem Softwareprodukt, der zu einem Versagen führen kann (ein Zustand)
        \end{defi}
        \begin{defi}
          \textbf{Irrtum} - ist eine menschliche Aktion, die einen Defekt verursacht. (ein Vorgang)
        \end{defi}
        \begin{defi}
          \textbf{Fehler} \textit{engl. Error} - Versagen | Defekt | Irrtum
        \end{defi}
        
        \section{Arten von Testhelfern}
        \begin{defi}
          \textbf{Stummel} \textit{engl. Stub} - ist ein rudimentär implementierter Teil der Software und dient als Platzhalter für noch nicht umgesetzte Funktionalität.
        \end{defi}
        \begin{defi}
          \textbf{Attrape} \textit{engl. Dummy} - simuliert die Implementierung zu Testzwecken
        \end{defi}
        \begin{defi}
          \textbf{Nachahmung} \textit{engl. Mock Object} - ist eine Attrappe mit zusätzlicher Funktionalität, wie bspw. das Einstellen der Reaktion der Nachahmung auf bestimmte Eingaben oder das Überprüfen des Verhaltens des 'Klienten'
        \end{defi}
        
        \section{Fehlerklassen}
        \begin{defi}
          \textbf{Anforderungsfehler} - Defekt im Pflichtenheft
        \end{defi}
        \begin {ex}
          \begin{enumerate}
          \item Inkorrekte Angabe der Benutzerwünsche
          \item Unvollständige Angaben über funktionale Anforderungen, Leistungsanforderungen...
          \item Inkosistenz verschiedener Anforderungen
          \item Undurchführbarkeit
            \end{enumerate}
        \end{ex}
        \begin{defi}
          \textbf{Entwurfsfehler} - Defekt in der Spezifikation
        \end{defi}
        \begin{ex}
          \begin{enumerate}
          \item Unvsollständige oder fehlerhafte Umsetzung der Anforderunge
          \item Inkosistenz der Spezifikation im Entwurf
          \item Inkosistenz zwischen Anforderung, Spezifikaion und Entwurf
          \end {enumerate}
          \end{ex}
        \begin {defi}
          \textbf{Implementierungsfehler} - Defekt im Programm
        \end{defi}
        \begin{ex}
          \begin{enumerate}
          \item Fehlerhafte Umsetzung der Spezifikation im Programm
          \end{enumerate}
        \end{ex}

        
        \section{Testverfahren}
        \subsection{Klassifikation}
        \begin{defi}
          \textbf{Dynamische Verfahren} - Das Übersetzte ausführbare Programm wird mit Testfällen versehen und ausgeführt. Stichprobenverfahren!
        \end{defi}
        \begin {ex}
          \begin{enumerate}
          \item Strukturtests \textit{engl. white/glass box testing}
            \begin{itemize}
            \item Kontrollflussorientierte Tests
            \item Datenflussorientierte Tests
            \end{itemize}
          \item Funktionale Tests \textit{engl. black box testing}
          \item Leistungstests \textit{engl. black box}
          \end {enumerate}
        \end{ex}

        \begin{defi}
          \textbf{Statische Verfahren} - Analyse des Quellcodes
        \end{defi}
        \begin{ex}
          \begin {enumerate}
          \item Manuelle Prüfmethoden (Inspektion, Review, Durchsichten) \textit{engl. inspection, review, walkthrough}
          \item Prüfprogramme (statische Analyse)
          \end{enumerate}
        \end{ex}

        \begin{defi}
          \textbf{White Box Testen} - Bestimmen der Werte mit Kenntnis von Kontroll- / Datenfluss
        \end{defi}

        \begin{defi}
          \textbf{Black Box Testen} - Bestimmen der Werte ohne Kenntnis von Kontroll- / Datenfluss; Nur aus der Spezifikation
        \end{defi}
        
        \subsection{Kontrollflussorientierte (KFO) Testverfahren}
        \begin{defi}
          \textbf{Zwischensprache} - Wir definieren eine Zwischensprache, bestehend aus:
          \begin{itemize}
          \item beliebigen Befehlen außer solchen, die die Ausführungsreihenfolge beeinflussen
          \item bedingten Sprungbefehlen zu beliebigen aber festen Stellen
          \item unbedingten Sprungbefehlen zu beliebigen aber festen Stellen
          \item einer beliebigen Anzahl an Variablen
          \end{itemize}
          Unsere Zwischensprache orientiert sich an Assembler.
          Die Realisierung ist unerheblich.
          Für Anwendung betrachte die Beispiele
        \end{defi}

        \begin{defi}
          \textbf{Strukturerhaltende Transformation} - Tranformation der Quellsprache in die Zwischensprache, die ausschließlich Befehle, die Ausführungsreihenfolge beeinflusse, durch die Zwischensprache ersetzt.
          Zudem sollen keine Optimierungen durchgeführt werden.
        \end{defi}

        \begin{defi}
          \textbf{Grundblock} - bezeichnet eine maximal lange Folge fortlaufender Anweisungen der Zwischensprache.
          \begin{itemize}
          \item Kontrollfluss tritt am Anfang ein
          \item Sprungbefehele nur am Ende
          \end{itemize}
        \end{defi}

        \begin{defi}
          \textbf{Kontrollflussgraph} \textit{engl. control flow graph} - ein gerichteter Graph wobei
          \begin{itemize}
          \item N die Menge aller Grundblöcke in P
          \item E die Menge der Kanten, wobei die Kanten die Ausführungsreihenfolge von je zwei Grundblöcken angeben.
          \item nStart der Startblock
          \item nStopp der Stoppblock
          \end{itemize}
        \end{defi}


        \begin{defi}
          \textbf{Zweig} \textit{engl. branch}  - Eine Kante \(e \in E\) in einem KFG G wird Zweig genannt. (gerichtet)
        \end{defi}

        \begin{defi}
          \textbf{Pfad} - Pfade im KFG die mit dem Startknoten anfangen und beim Stoppknoten aufhören heißen \textbf{vollständige Pfade}
        \end{defi}

        \begin{defi}
          \textbf{Anweisungsüberdeckung} \textit{engl. statement coverage} - Die Teststrategie Anweisungsüberdeckung verlangt die Ausführung aller Grundblöcke des Programms P
        \end{defi}

        \begin{defi}
          \textbf{Zweigüberdeckung} \textit{engl. branch coverage} - Die Teststrategie Zweigüberdeckung verlangt das Traversieren aller Zweige im KFG
        \end{defi}

        \begin{defi}
          \textbf{Pfadüberdeckung} \textit{engl. path coverage} - Die Teststrategie Pfadüberdeckung fordert die Ausführung aller unterschiedlichen, vollständigen Pfade im Programm.
        \end{defi}

        \begin{why}
          \begin{enumerate}
          \item Mächtigste KFO Teststrategie
          \end{enumerate}
        \end{why}
        
        \begin{whynot}
          \begin{enumerate}
          \item Pfadanzahl wächst bei Schleifen stark an.
          \item Manche Pfade nicht ausführbar durch ausschließende Bedingungen
          \item Nicht praktikabel
          \end{enumerate}
        \end{whynot}

        \begin{defi}
          \textbf{Bedingungsüberdeckungsverfahren} \textit{engl. Condition coverage} - Zweigüberdeckung nicht ausreichend bei hierarchischen bedingungen. Deshalb andere Verfahren für Bedingungen.
          \begin{enumerate}
          \item Einfache BÜ
          \item Mehrfache BÜ
          \item Minimal-mehrfache BÜ
          \end{enumerate}
        \end{defi}

        \begin{defi}
          \textbf{Einfache Bedingungsüberdeckung} - fordert, dass jede atomare Bedingung einmal mit Wahr \ul{und} einmal mit Falsch belegt wird.
        \end{defi}

        \begin{defi}
          \textbf{Mehrfache Bedingungsüberdeckung} - fordert, dass die atomaren Bedingungen mit \ul{allen m\"oglichen Kombinationen} der Wahrheitswerte W und F belegt werden.
        \end{defi}

        \begin{whynot}
          \begin{enumerate}
          \item Ergibt bei n Atomaren Bedingungen \(2^n\) Kombinationen
          \end{enumerate}
        \end{whynot}

        \begin{defi}
          \textbf{Minimal-mehrfache Bedingungsüberdeckung} - fordert, dass \ul{jede} Bedingung, ob atomar oder zusammengesetzt, jeweils zu W und F evaluieren muss.
        \end{defi}

        \begin{defi}
          \textbf{Subsumieren} - Ein Testverfahren für Kritierium x subsumiert ein Testverfahren für Kriterium y, wenn jede Menge von Pfaden, die Kriterium x erfüllt auch Kriterium y erfüllt.
        \end{defi}

        % TODO - Add Hierarchie der Testverfahren %
        
        \begin{defi}
          \textbf{Kurzauswertung} - die Auswertung einer zusammengesetzten Bedingung wird abgebrochen, sobald das Ergebnis feststeht.
          --> Beeinflusst Wahl der Eingaben. Es muss mehr getestet werden.
        \end{defi}
        
        \subsection{Datenflussorientiert}
        -- Nothing to see here - Keep on moving --
        % Irgendwo in den Folien? %
        \subsection{Funktionale Tests}
        \begin{defi}
          \textbf{Funktionale Tests} \textit{engl. Functional Tests} - Testen die Spezifizierte Funktionalität ohne Kenntnis der internen Struktur des Testlings. Demnach werden die Testf\"alle aus der Spezifikation abgeleitet.
        \end{defi}
        \begin{why}
          \begin{enumerate}
          \item Testf\"alle unabh\"angig von der Implentierung (vorher \& gleichzeitig)
          \item Vermeidet Kurzsichtigkeit bei der Auswahl
          \end{enumerate}
        \end{why}
        \begin{whynot}
          \begin{enumerate}
          \item M\"ogliche kritische Pfade nicht bekannt \& nicht getestet
          \end{enumerate}
        \end{whynot}

        \begin{defi}
          \textbf{\"Aquivalenzklassenbildung} - Bestimmung von Test durch bilden der \"Aquivalenzklassen und Auswahl von Repres\"antanten
        \end{defi}

        \begin{defi}
          \textbf{Grenzwertanalyse} - Weiterentwicklung der \"Aquivalenzklassenbildung. Verwendet aber nicht zuf\"allige Repres\"antanten sondern, solche die auf dem Rand liegen.
          Also explizit von beiden Ann\"aherung aus beiden Richtungen.
        \end{defi}

        \begin{defi}
          \textbf{Zufallstest} \textit{engl. Random Testing} - Testen der Funktionalität mit zuf\"alligen Testf\"allen.
        \end{defi}

        \subsubsection{Verwendung von Testhelfern}
        Objekte leben nicht isoliert, sondern arbeiten in einer Anwendung zusammen. Um trotzdem ein unabh\"angiges Testen zu erm\"oglichen werden beim Testen Testhelfer eingesetzt, welche die fehlende Funtionalit\"at simulieren. Dann werden die Testhelfer sukzessiv durch echte Implementierungen ersetzt.

        \subsubsection{Test von Zustandsautomaten}
        Falls eine Komponente einen internen Zustand hat, k\"onnen hieraus Testf\"alle abgeleitet werden. Dabei sollte es das Ziel sein, mindestens alle Zust\"ands\"uberg\"ange einmal durchlaufen zu haben. Dies garantiert allerdings \ul{keinen} vollst\"andigen Test.

        \begin{defi}
          \textbf{\(\alpha - \omega -Zyklus \)} - bezeichnet den kompletten Lebenszyklus eines Objektes, von der Speicherallkoation (vor Ausf\"uhrung jeglicher Konstruktoren) bis zur Speicherfreigabe (nach Ausf\"uhrung der Destrukturen)
        \end{defi}
        
        
        \subsection{Leistungstests}
        \begin{defi}
          \textbf{Lasttest} - Testet das System/die Komponente auf Zuverl\"assigkeit und das Einhalten der Spezifikation \ul{im erlaubten Grenzbereich}.
        \end{defi}

        \begin{defi}
          \textbf{Stresstest} - Testet das Verhalten des Systems beim \ul{\"Uberschreiten} der definierten Grenzen
        \end{defi}
        
        
        \subsection{Manuelle Prüfmethoden}
        \begin{why}
        Nur durch manuelle Pr\"ufung k\"onnen semantische Fehler gefunden werden. 
        \end{why}
        \begin{whynot}
          Manuelle Pr\"ufung ist sehr aufwendig und ben\"otigt viele Ressourcen und Zeit.
          Dabei entsteht zudem psychologischer Druck auf Einzelne, welcher zu sozialen Konflikten f\"uhren kann.
        \end{whynot}
        
          \textbf{Stufen der Manuellen Pr\"ufung (absteigend)}
          \begin{enumerate}
          \item Inspektion \textit{engl. Inspection}
          \item \"Uberpr\"ufung \textit{engl. Review}
          \item Durchsicht \textit{engl. Walkthrough}
          \end{enumerate}
        

        \subsubsection{Inspektion}
        \begin{defi}
          \textbf{Inspektion} - Die Inspektion ist eine formale \ul{Qualit\"atssicherungstechnik}, bei der Anforderungen, Entwurf oder Code eingehend durch eine vom Autor verschiedene Person oder eine Gruppe von Personen begutachtet werden. Zweck ist das Finden von Fehlern, Verst\"oßen gegen Entwicklungsstandards und anderen Problemen.
        \end{defi}

        \begin{why}
          \begin{enumerate}
          \item Auf alle Softwaredokumente anwendbar
          \item Jederzeitig und fr\"uhzeitig durchf\"uhrbar
          \item Sehr effektiv in der Praxis
          \item Return on Investment sehr hoch
          \end{enumerate}
        \end{why}
        \begin{whynot}
          \begin{enumerate}
          \item Aufwendig
          \item Verbraucht Zeit vieler Mitarbeiter
          \item Somit teuer
          \item ``statisch'' (im Gegensatz zum Testen)
          \end{enumerate}
        \end{whynot}

          \textbf{Phasen einer Inspektion}
        \begin{enumerate}
        \item Vorbereitung
        \item Individuelle Fehlersuche (IF)
        \item Gruppensitzung (GS)
        \item Nachbereitung
        \item Prozessverbesserung
        \end{enumerate}

          \textbf{Rollen}
          \begin{enumerate}
          \item Inspektionsleiter
          \item Moderator
          \item Schriftf\"uhrer
          \item Editor
          \item Autor
          \end{enumerate}

          \textbf{Defektklassifikation}
          \begin{enumerate}
          \item schwerwiegend \textit{engl. Major} oder leicht \textit{engl. Minor}
            \item Defekt \textit{engl. Defect}, Anregung \textit{engl. Suggestion} oder Frage \textit{engl. Question}
          \end{enumerate}

          \textbf{Lesetechniken}
          \begin{enumerate}
          \item Ad-Hoc (keine Vorgaben)
          \item Pr\"uflisten
          \item Perspektiven Szenarien
          \end{enumerate}

          \begin{ex}
            Verwendung von Programmen um direkt in der IDE Code Kommentare angezeigt zu bekommen.
            Verwendung von Programmen wie Gerrit um erst einen Review und Genehmigung vor der Einbuchung zu Erhalten.....
          \end{ex}
          
            

          \subsection{Prüfprogramme}
        
\section{Testphasen}
\subsection{Komponententest}
\subsection{Integrationstest}
\subsection{Systemtest}
\subsection{Abnahmetest}
\section{Software-Inspektionen}
\subsection{Phasen}
\subsubsection{Vorbereitung}
\subsubsection{Individuelle Fehlersuche (IF)}
\subsubsection{Gruppensitzung (GS)}
\subsubsection{Nachbereitung}
\subsubsection{Prozessverbesserung}
\section{Integrationsstrategien}
\section{Systemtests}

\end{document}
