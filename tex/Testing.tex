\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[light,condensed,math]{kurier}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}
\usepackage{graphicx}
\usepackage{floatrow}
\usepackage{float}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{soul} % Underline

\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Vorteile}[section]
\newtheorem{whynot}{Nachteile}[section]

\setul{5pt}{.4pt}
\title{SWT 1: Testen}
\author{Sebastian Markgraf \& Adrian E. Lehmann}

\begin{document}
	\maketitle
	\begin{large}
	\begin{center} „Testing shows the presence of bugs, not their absence.“\newline
		- Edsger W. Dijkstra
	\end{center}
	\end{large}
	\tableofcontents
	\newpage
        \section{Arten von Fehlern}
        \begin{defi}
          \textbf{Versagen} - Abweichung des Verhaltens der Software von der Spezifikation (ein Ereignis)
        \end {defi}
        \begin{defi}
          \textbf{Defekt} - ist ein Mangel in einem Softwareprodukt, der zu einem Versagen führen kann (ein Zustand)
        \end{defi}
        \begin{defi}
          \textbf{Irrtum} - ist eine menschliche Aktion, die einen Defekt verursacht. (ein Vorgang)
        \end{defi}
        \begin{defi}
          \textbf{Fehler} \textit{engl. Error} - Versagen | Defekt | Irrtum
        \end{defi}
        
        \section{Arten von Testhelfern}
        \begin{defi}
          \textbf{Stummel} \textit{engl. Stub} - ist ein rudimentär implementierter Teil der Software und dient als Platzhalter für noch nicht umgesetzte Funktionalität.
        \end{defi}
        \begin{defi}
          \textbf{Attrape} \textit{engl. Dummy} - simuliert die Implementierung zu Testzwecken
        \end{defi}
        \begin{defi}
          \textbf{Nachahmung} \textit{engl. Mock Object} - ist eine Attrappe mit zusätzlicher Funktionalität, wie bspw. das Einstellen der Reaktion der Nachahmung auf bestimmte Eingaben oder das Überprüfen des Verhaltens des 'Klienten'
        \end{defi}
        
        \section{Fehlerklassen}
        \begin{defi}
          \textbf{Anforderungsfehler} - Defekt im Pflichtenheft
        \end{defi}
        \begin {ex}
          \begin{enumerate}
          \item Inkorrekte Angabe der Benutzerwünsche
          \item Unvollständige Angaben über funktionale Anforderungen, Leistungsanforderungen...
          \item Inkosistenz verschiedener Anforderungen
          \item Undurchführbarkeit
            \end{enumerate}
        \end{ex}
        \begin{defi}
          \textbf{Entwurfsfehler} - Defekt in der Spezifikation
        \end{defi}
        \begin{ex}
          \begin{enumerate}
          \item Unvsollständige oder fehlerhafte Umsetzung der Anforderunge
          \item Inkosistenz der Spezifikation im Entwurf
          \item Inkosistenz zwischen Anforderung, Spezifikaion und Entwurf
          \end {enumerate}
          \end{ex}
        \begin {defi}
          \textbf{Implementierungsfehler} - Defekt im Programm
        \end{defi}
        \begin{ex}
          \begin{enumerate}
          \item Fehlerhafte Umsetzung der Spezifikation im Programm
          \end{enumerate}
        \end{ex}

        
        \section{Testverfahren}
        \subsection{Klassifikation}
        \begin{defi}
          \textbf{Dynamische Verfahren} - Das Übersetzte ausführbare Programm wird mit Testfällen versehen und ausgeführt. Stichprobenverfahren!
        \end{defi}
        \begin {ex}
          \begin{enumerate}
          \item Strukturtests \textit{engl. white/glass box testing}
            \begin{itemize}
            \item Kontrollflussorientierte Tests
            \item Datenflussorientierte Tests
            \end{itemize}
          \item Funktionale Tests \textit{engl. black box testing}
          \item Leistungstests \textit{engl. black box}
          \end {enumerate}
        \end{ex}

        \begin{defi}
          \textbf{Statische Verfahren} - Analyse des Quellcodes
        \end{defi}
        \begin{ex}
          \begin {enumerate}
          \item Manuelle Prüfmethoden (Inspektion, Review, Durchsichten) \textit{engl. inspection, review, walkthrough}
          \item Prüfprogramme (statische Analyse)
          \end{enumerate}
        \end{ex}

        \begin{defi}
          \textbf{White Box Testen} - Bestimmen der Werte mit Kenntnis von Kontroll- / Datenfluss
        \end{defi}

        \begin{defi}
          \textbf{Black Box Testen} - Bestimmen der Werte ohne Kenntnis von Kontroll- / Datenfluss; Nur aus der Spezifikation
        \end{defi}
        
        \subsection{Kontrollflussorientierte (KFO) Testverfahren}
        \begin{defi}
          \textbf{Zwischensprache} - Wir definieren eine Zwischensprache, bestehend aus:
          \begin{itemize}
          \item beliebigen Befehlen außer solchen, die die Ausführungsreihenfolge beeinflussen
          \item bedingten Sprungbefehlen zu beliebigen aber festen Stellen
          \item unbedingten Sprungbefehlen zu beliebigen aber festen Stellen
          \item einer beliebigen Anzahl an Variablen
          \end{itemize}
          Unsere Zwischensprache orientiert sich an Assembler.
          Die Realisierung ist unerheblich.
          Für Anwendung betrachte die Beispiele
        \end{defi}

        \begin{defi}
          \textbf{Strukturerhaltende Transformation} - Tranformation der Quellsprache in die Zwischensprache, die ausschließlich Befehle, die Ausführungsreihenfolge beeinflusse, durch die Zwischensprache ersetzt.
          Zudem sollen keine Optimierungen durchgeführt werden.
        \end{defi}

        \begin{defi}
          \textbf{Grundblock} - bezeichnet eine maximal lange Folge fortlaufender Anweisungen der Zwischensprache.
          \begin{itemize}
          \item Kontrollfluss tritt am Anfang ein
          \item Sprungbefehele nur am Ende
          \end{itemize}
        \end{defi}

        \begin{defi}
          \textbf{Kontrollflussgraph} \textit{engl. control flow graph} - ein gerichteter Graph wobei
          \begin{itemize}
          \item N die Menge aller Grundblöcke in P
          \item E die Menge der Kanten, wobei die Kanten die Ausführungsreihenfolge von je zwei Grundblöcken angeben.
          \item nStart der Startblock
          \item nStopp der Stoppblock
          \end{itemize}
        \end{defi}


        \begin{defi}
          \textbf{Zweig} \textit{engl. branch}  - Eine Kante \(e \in E\) in einem KFG G wird Zweig genannt. (gerichtet)
        \end{defi}

        \begin{defi}
          \textbf{Pfad} - Pfade im KFG die mit dem Startknoten anfangen und beim Stoppknoten aufhören heißen \textbf{vollständige Pfade}
        \end{defi}

        \begin{defi}
          \textbf{Anweisungsüberdeckung} \textit{engl. statement coverage} - Die Teststrategie Anweisungsüberdeckung verlangt die Ausführung aller Grundblöcke des Programms P
        \end{defi}

        \begin{defi}
          \textbf{Zweigüberdeckung} \textit{engl. branch coverage} - Die Teststrategie Zweigüberdeckung verlangt das Traversieren aller Zweige im KFG
        \end{defi}

        \begin{defi}
          \textbf{Pfadüberdeckung} \textit{engl. path coverage} - Die Teststrategie Pfadüberdeckung fordert die Ausführung aller unterschiedlichen, vollständigen Pfade im Programm.
        \end{defi}

        \begin{why}
          \begin{enumerate}
          \item Mächtigste KFO Teststrategie
          \end{enumerate}
        \end{why}
        
        \begin{whynot}
          \begin{enumerate}
          \item Pfadanzahl wächst bei Schleifen stark an.
          \item Manche Pfade nicht ausführbar durch ausschließende Bedingungen
          \item Nicht praktikabel
          \end{enumerate}
        \end{whynot}

        \begin{defi}
          \textbf{Bedingungsüberdeckungsverfahren} \textit{engl. Condition coverage} - Zweigüberdeckung nicht ausreichend bei hierarchischen bedingungen. Deshalb andere Verfahren für Bedingungen.
          \begin{enumerate}
          \item Einfache BÜ
          \item Mehrfache BÜ
          \item Minimal-mehrfache BÜ
          \end{enumerate}
        \end{defi}

        \begin{defi}
          \textbf{Einfache Bedingungsüberdeckung} - fordert, dass jede atomare Bedingung einmal mit Wahr \underline{und} einmal mit Falsch belegt wird.
        \end{defi}

        \begin{defi}
          \textbf{Mehrfache Bedingungsüberdeckung} - fordert, dass die atomaren Bedingungen mit \underline{allen möglichen Kombinationen} der Wahrheitswerte W und F belegt werden.
        \end{defi}

        \begin{whynot}
          \begin{enumerate}
          \item Ergibt bei n Atomaren Bedingungen \(2^n\) Kombinationen
          \end{enumerate}
        \end{whynot}

        \begin{defi}
          \textbf{Minimal-mehrfache Bedingungsüberdeckung} - fordert, dass \underline{jede} Bedingung, ob atomar oder zusammengesetzt, jeweils zu W und F evaluieren muss.
        \end{defi}

        \begin{defi}
          \textbf{Subsumieren} - Ein Testverfahren für Kritierium x subsumiert ein Testverfahren für Kriterium y, wenn jede Menge von Pfaden, die Kriterium x erfüllt auch Kriterium y erfüllt.
        \end{defi}

        % TODO - Add Hierarchie der Testverfahren %
        
        \begin{defi}
          \textbf{Kurzauswertung} - die Auswertung einer zusammengesetzten Bedingung wird abgebrochen, sobald das Ergebnis feststeht.
          --> Beeinflusst Wahl der Eingaben. Es muss mehr getestet werden.
        \end{defi}
        
        \subsection{Datenflussorientiert}
        -- Nothing to see here - Keep on moving --
        \subsection{Funktionale Tests}
        
\subsection{Leistungstests}
\subsection{Manuelle Prüfmethoden}
\subsection{Prüfprogramme}
\section{Testphasen}
\subsection{Komponententest}
\subsection{Integrationstest}
\subsection{Systemtest}
\subsection{Abnahmetest}
\section{Software-Inspektionen}
\subsection{Phasen}
\subsubsection{Vorbereitung}
\subsubsection{Individuelle Fehlersuche (IF)}
\subsubsection{Gruppensitzung (GS)}
\subsubsection{Nachbereitung}
\subsubsection{Prozessverbesserung}
\section{Integrationsstrategien}
\section{Systemtests}

\end{document}
