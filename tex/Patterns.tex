\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{color}


\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Anwendung}[section]

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\renewcommand{\lstlistingname}{Code Snippet}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize,        % size of fonts used for the code
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve},     % string literal style\\
}


\title{SWT 1: Entwurfsmuster by example}
\author{Adrian E. Lehmann}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Varianten Muster}

\subsection{Strategie Entwurfsmuster}

\textit{engl. Strategy pattern}

\begin{defi}
	Das Strategieentwurfsmuster beschreibt eine Familie von Algorithmen, verkapselt diese und macht sie auswechselbar. Damit können Algorithmen unabhängig von Klienten variiert werden.
\end{defi}

\begin{ex}[Java]
	Das folgende Beispiel wird nun eine untereinander austauschbare Familie von Sortieralgorithmen darstellen


	\lstinputlisting[language=Java, caption=Definiton der Strategie Schnittstelle]{examples/strategy/Sorter.java}
	\lstinputlisting[language=Java, caption=Erste Implementierung]{examples/strategy/BubbleSort.java}
	\lstinputlisting[language=Java,caption=Zweite Implementierung]{examples/strategy/QuickSort.java}
	\lstinputlisting[language=Java, caption=Implementierung]{examples/strategy/Main.java}
		
\end{ex}

\begin{why}
	"Swtich-less" programming. Strategies erlauben es uns ohne switch case anweisungen zwischen verschiedenen Anwendungsfällen Algorithmen zu wechseln.
\end{why}


\subsection{Dekorierer}

\textit{engl. Decorator pattern}

\begin{defi}
	Der Dekorierer fügt Objekten dynamisch Funktionalität hinzu.
\end{defi}

\begin{ex}[Java]
	Im folgenden Beispiel werden wird Eis mit Extras "dekorieren".
	
	
	\lstinputlisting[language=Java, caption=Erstellen userer zu dekorierenden Schnittstelle Schnittstelle]{examples/decorator/IceCream.java}
	\lstinputlisting[language=Java, caption=Schnittstellen Implementierung]{examples/decorator/GenericIceCream.java}
	\lstinputlisting[language=Java,caption=Dekorierer]{examples/decorator/IceCreamDecorator.java}
	\lstinputlisting[language=Java,caption=Konkrete Implementierung des Dekorierers]{examples/decorator/WithChocolateChips.java}
	\lstinputlisting[language=Java,caption=Weitere konkrete Implementierung des Dekorierers]{examples/decorator/WithCaramel.java}
	\lstinputlisting[language=Java, caption=Verwendung]{examples/decorator/Main.java}
	
\end{ex}

\begin{why}
	Wenn Zusatzoperationen welche nur teilweise auftreten auf weitere Objekte delegiert werden sollen, während alte Objekte Fortbestand haben sollen.
\end{why}


	
\end{document}