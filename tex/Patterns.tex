\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{ntheorem}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{color}



\theoremstyle{break}
\newtheorem{defi}{Definition}[section]
\newtheorem{ex}{Beispiel}[section]
\newtheorem{why}{Anwendung}[section]

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\renewcommand{\lstlistingname}{Code Snippet}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize,        % size of fonts used for the code
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve},     % string literal style\\
}


\title{SWT 1: Entwurfsmuster by example}
\author{Adrian E. Lehmann}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Varianten Muster}

\subsection{Strategie Entwurfsmuster}

\textit{engl. Strategy pattern}

\begin{defi}
	Das Strategieentwurfsmuster beschreibt eine Familie von Algorithmen, verkapselt diese und macht sie auswechselbar. Damit können Algorithmen unabhängig von Klienten variiert werden.
\end{defi}

\begin{ex}[Java]
	Das folgende Beispiel wird nun eine untereinander austauschbare Familie von Sortieralgorithmen darstellen


	\lstinputlisting[language=Java, caption=Definiton der Strategie Schnittstelle]{examples/strategy/Sorter.java}
	\lstinputlisting[language=Java, caption=Erste Implementierung]{examples/strategy/BubbleSort.java}
	\lstinputlisting[language=Java,caption=Zweite Implementierung]{examples/strategy/QuickSort.java}
	\lstinputlisting[language=Java, caption=Implementierung]{examples/strategy/Main.java}
		
\end{ex}

\begin{why}
	"Swtich-less" programming. Strategies erlauben es uns ohne switch case anweisungen zwischen verschiedenen Anwendungsfällen Algorithmen zu wechseln.
\end{why}

\newpage
\subsection{Dekorierer}

\textit{engl. Decorator pattern}

\begin{defi}
	Der Dekorierer fügt Objekten dynamisch Funktionalität hinzu.
\end{defi}

\begin{ex}[Java]
	Im folgenden Beispiel werden wir Eis mit Extras "dekorieren".
	
	
	\lstinputlisting[language=Java, caption=Erstellen userer zu dekorierenden Schnittstelle Schnittstelle]{examples/decorator/IceCream.java}
	\lstinputlisting[language=Java, caption=Schnittstellen Implementierung]{examples/decorator/GenericIceCream.java}
	\lstinputlisting[language=Java,caption=Dekorierer]{examples/decorator/IceCreamDecorator.java}
	\lstinputlisting[language=Java,caption=Konkrete Implementierung des Dekorierers]{examples/decorator/WithChocolateChips.java}
	\lstinputlisting[language=Java,caption=Weitere konkrete Implementierung des Dekorierers]{examples/decorator/WithCaramel.java}
	\lstinputlisting[language=Java, caption=Verwendung]{examples/decorator/Main.java}
	
\end{ex}

\begin{why}
	Wenn Zusatzoperationen welche nur teilweise auftreten auf weitere Objekte delegiert werden sollen, während alte Objekte Fortbestand haben sollen.
\end{why}


\newpage
\subsection{Kompositum}

\textit{engl. Composite pattern}

\begin{defi}
	Ein Kompositum ist eine Gruppe von Objekten, welche genauso behandelt wird wie eine einzelne Instanz des selben Objekttypen
\end{defi}

\begin{ex}[Java API: JComponent]
	In der Java API enthalten ist der JComponent, welcher wiederum weitere Components enthalten kann.
	Zum Beispiel kann ein JPanel ein Label und ein weiteres Panel mit einem Button und einem Bild enthalten und trotzdem wird das obere JPanel genauso als JComponent behandelt wie die einzelnen enthaltenen JComponents behandelt werden (würden).
\end{ex}

\begin{why}
	Wenn Unterscheide zwischen einer einzelnen Ausführung einer Klasse und einer Zusammensetzung dieser für die Verwendung nicht von Relevanz sind.
\end{why}


\newpage
\subsection{Fabrikmethode}

\textit{engl. Factory Method}

\begin{defi}
	Eine Schnittstelle zur Instanziierung neuer Objekte, welche die konkrete Auswahl der konkreten zu instanziierenden Klasse seinen Unterklassen überlässt.
\end{defi}

\begin{ex}[Java]
	Im folgenden Beispiel werden wir Typen von Studenten ihre Smartphones "bauen" lassen. (Studenten bauen i.A. keine Smartphones, aber es musste ja Beispiel her)

	\lstinputlisting[language=Java, caption=Erstellen unserer Schnittestelle\, von welcher die Subklassen durch die Frabrikmethode gebaut werden sollen Schnittstelle]{examples/factorymethod/Smartphone.java}
	\lstinputlisting[language=Java, caption=1. Schnittstellen Implementierung]{examples/factorymethod/GenericSmartphone.java}
	\lstinputlisting[language=Java, caption=2. Schnittstellen Implementierung]{examples/factorymethod/uPhone.java}
	\lstinputlisting[language=Java,caption=Abstrakte Klasse\, welche durch Fabrikmethode Objekte bauen soll]{examples/factorymethod/Student.java}
	\lstinputlisting[language=Java,caption=Konkrete Implementierung der Klasse mit Fabrikmethode]{examples/factorymethod/NormalStudent.java}
	\lstinputlisting[language=Java,caption=Weitere Implementierung der Klasse mit Fabrikmethode]{examples/factorymethod/BusinessStudent.java}
	\lstinputlisting[language=Java, caption=Verwendung]{examples/factorymethod/Main.java}
\end{ex}

\begin{why}
	\begin{enumerate}
		\item 	Wenn eine Klasse die ihre benötigten zu instanziierenden Objekte nicht kennen kann.
		\item Wenn eine Klasse benötigt, dass ihre Unterklassen Kontrolle über die konkrete Auswahl eines Objekttyps haben müssen.
		\item Zur Insanziierung eines konkreten Objektes welche das Schablonenmethoden Muster verwendet
	\end{enumerate}

	
\end{why}


	
\end{document}